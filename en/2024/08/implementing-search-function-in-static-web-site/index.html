<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Implementing the search function in a static web site – La màquina de Turing</title>
    <meta property="og:title" content="Implementing the search function in a static web site">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://lamaquinadeturing.su/en/2024/08/implementing-search-function-in-static-web-site/">
    <meta property="og:image" content="https://lamaquinadeturing.su/assets/media/search_opt1200.jpg">
    <link rel="stylesheet" href="/assets/css/linked.css" type="text/css">
<style>/* inlined.css */
html {
    font-size: 20px;
    --font-title: "Pixelar", -apple-system, BlinkMacSystemFont, sans-serif;
    --font-body: "Barlow", -apple-system, BlinkMacSystemFont, sans-serif;
    --font-size-18: .9rem;
    --color-text: hsl(0, 0%, 0%);
    --color-indifferent: hsl(0, 0%, 40%);
    --color-accent: hsl(120, 95%, 42%);
    --color-title: hsl(285, 4%, 21%);
    --color-border: hsl(285, 4%, 21%);
    --color-bg: hsl(0, 0%, 100%);
}

*,
*::before,
*::after {
    box-sizing: border-box;
}

body {
    margin: 0;
    font-size: var(--font-size-18);
    font-family: var(--font-body);
    line-height: 1.8;
    color: var(--color-text);
    overflow-x: hidden;
    font-weight: normal;
    background: url("/assets/img/dots.svg") var(--color-bg);
    background-size: 2px 2px;
    background-attachment: fixed;
}

h1, h2, h3, h4, h5, h6 {
    color: var(--color-title);
    margin: 1em 0 .5em 0;
    line-height: 1.4;
    font-weight: normal;
}

h1 { font-size: 2.4rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.7rem; }
h4 { font-size: 1.5rem; }
h5 { font-size: 1.3rem; }
h6 { font-size: 1.1rem; }

article h1 { font-size: 1.7rem; }
article h2 { font-size: 1.5rem; }
article h3 { font-size: 1.3rem; }
article h4 { font-size: 1.1rem; }
article h5 { font-size: 0.9rem; }
article h6 { font-size: 0.7rem; }
</style>
<script>
function loadStyleSheets(...sources) {
    for (const src of sources) {
        if (document.createStyleSheet) document.createStyleSheet(src);
        else {
            var stylesheet = document.createElement('link');
            stylesheet.href = src;
            stylesheet.rel = 'stylesheet';
            stylesheet.type = 'text/css';
            document.getElementsByTagName('head')[0].appendChild(stylesheet);
        }
    }
}
loadStyleSheets('/assets/css/deferred.css');
</script>
<script defer src="/assets/js/combined.js"></script>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com/">
    <link rel="dns-prefetch" href="https://s.w.org/">
    <script>
        const page_lang = "en";
        const site_languages = ["ca","en","es"];
    </script>
    <script defer data-domain="lamaquinadeturing.su" src="https://plausible.factoria.lu/js/script.js"></script>
</head>

<body class="home blog eightbit-effect loading" itemscope="" itemtype="http://schema.org/WebPage">
    <div id="page">

        <header id="site-header" itemscope="" itemtype="http://schema.org/WPHeader">
    <div id="branding-wrapper" class="element__frame">
        <a href="https://lamaquinadeturing.su/en" rel="home" itemscope="" itemtype="http://schema.org/Brand">
            <h1 class="site-title" itemprop="name">La màquina de Turing</h1>
        </a>
    </div>

    <nav class="element__frame desktop-media">
        <!-- <p class="bar__title">Lang</p> -->

        <ul class="pull clear">
            <li class="menu-item"><span>en</span></li>
            
                
                    <li class="menu-item"><a href="https://lamaquinadeturing.su/ca">ca</a></li>
                
            
                
            
                
                    <li class="menu-item"><a href="https://lamaquinadeturing.su/es">es</a></li>
                
            
        </ul>
    </nav>

    <nav itemscope="" itemtype="http://schema.org/SiteNavigationElement" class="element__frame" id="mobile-window">
        <p class="bar__title mobile-media">Menu</p>

        <a id="nav-toggle" class="nav-slide-button" href="#"><span></span></a>

        <ul id="primary-menu" class="pull clear">
            <li class="menu-item mobile-media"><span>en</span></li>
            
                
                    <li class="menu-item mobile-media"><a href="https://lamaquinadeturing.su/ca">ca</a></li>
                
            
                
            
                
                    <li class="menu-item mobile-media"><a href="https://lamaquinadeturing.su/es">es</a></li>
                
            

            <li>
                <div class="search-form">
                    <label>
                        <span class="screen-reader-text">Search for:</span>
                        <input type="search" class="search-field" placeholder="Search…" name="q">
                    </label>
                    <input type="submit" class="search-submit" value="Search">
                </div>
            </li>

            
                
                
            
                
                
                <li class="menu-item desktop-media"><a href="/en/cybernetics/">Cybernetics</a></li>
                
                <li class="menu-item desktop-media"><a href="/en/lzhenauka/">Lzhenauka</a></li>
                
                <li class="menu-item desktop-media"><a href="/en/web/">Web</a></li>
                
            
                
                
            
        </ul>

        <ul class="search-results hidden"></ul>
    </nav>

    
    <ul class="social-media-profiles element__frame">
        <li>
            <p class="bar__title">
                Social </p>
        </li>
        
            
            
            
        <li><a href="https://mastodont.cat/@urixturing"><img src="/assets/img/mastodon.svg" width="12" height="12"></a></li>
        
        
        <li><a href="https://github.com/maquinadeturing/lamaquinadeturing.su"><img src="/assets/img/github.svg" width="12" height="12"></a></li>
        
    </ul>
    
</header>
<div class="clear"></div>

        
        <section class="grid__single" itemscope="" itemtype="http://schema.org/BlogPost">

            <div class="grid__item">
    <article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting" id="post-5"
        class="element__frame post type-post status-publish format-standard has-post-thumbnail hentry">
        <header class="entry-header">
            <span class="posted-on">9 Aug 2024</span>
            
            <div>
            
            
            <a href="/en/web/" class="category-name" itemprop="articleSection">Web</a>
            
            </div>
            
            <h2 class="entry__title" itemprop="headline">Implementing the search function in a static web site</h2>
        </header>
        <div class="entry-content" itemprop="articleBody">
            
            
            <div class="entry-thumbnail-single landscape" itemprop="image">
                <img src="/assets/media/search_opt.jpg" srcset="/assets/media/search_opt698.jpg 698w, /assets/media/search_opt1078.jpg 1078w" sizes="(max-width: 800px) 698px, (max-width: 1200px) 1078px, 698px" class="attachment-large size-large wp-post-image" alt="Cuff’s solar microscope in “Mikroskopische Gemüths - und Augen-Ergötzung”, vol. 3, by M. F. Ledermüller (1759–63).">
            </div>
            
            <div class="entry-thumbnail-caption"><p>Cuff’s solar microscope in <a href="https://publicdomainreview.org/collection/microscopic-delights/">“Mikroskopische Gemüths - und Augen-Ergötzung”</a>, vol. 3, by M. F. Ledermüller (1759–63).</p>
</div>
            
            

            
            

            <p>Static web sites <a href="/en/2024/08/the-case-for-a-better-web/">are the best</a>. They are fast, lightweight, safe and content-centric. However, not having a server comes with its sacrifices. I can go without forms, user accounts or comments, but the thing I miss the most is <em>searching</em>.</p>

<h2 id="heading-the-poor-mans-search-function" class="heading">
<a class="heading-link" href="#heading-the-poor-mans-search-function">§</a>The poor man’s search function</h2>

<p>Usually, the alternative has been the <code class="language-plaintext highlighter-rouge">site:</code> operator in Google: a form in your website would transform the search string into a <code class="language-plaintext highlighter-rouge">site:</code> query and redirect it to Google. Purists can do the same with <a href="https://duckduckgo.com/duckduckgo-help-pages/results/syntax/" class="link-external">DuckDuckGo</a>. But that leaves me relying on notoriously unreliable companies, which can drop this feature at any moment or hide it behind a pawyall.</p>

<p>And I wondered: is there a way to have my own search function?</p>

<h2 id="heading-is-static-search-even-possible" class="heading">
<a class="heading-link" href="#heading-is-static-search-even-possible">§</a>Is static search even possible?</h2>

<p>My wishlist for a search function was:</p>
<ol>
  <li>Doesn’t depend on an external API.</li>
  <li>Has to be lightweight, ie. downloading all the posts and searching them is not an option.</li>
  <li>Has to be reasonably good at finding results, but not perfect. For instance, I can do without full-text search.</li>
</ol>

<p>With that in mind, I started designing my own static search function. The basic idea was to generate some kind of index that would allow for static searches using Javascript.</p>

<p>There are some nice Javascript libraries that will consume texts and provide a search function, like <a href="https://lunrjs.com" class="link-external">Lunr</a>. It even lets you <a href="https://lunrjs.com/guides/index_prebuilding.html" class="link-external">pre-build the serch index</a>, so it can be downloaded as a static JSON file. As a test, I created a Lunr JSON index with <a href="/es/2020/04/cibernetica-en-el-breve-diccionario-filosofico-1954/">the</a> <a href="/es/2020/05/cibernetica-al-servicio-del-comunismo/">three</a> <a href="/es/2020/05/cuando-la-inteligencia-artificial-desplazo-la-cibernetica/">posts</a> in Spanish in the blog, as they are the longest right now. The result is the following:</p>

<table>
  <thead>
    <tr>
      <th>Posts</th>
      <th>Rendered Post Size<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>
</th>
      <th>Lunr JSON Index Size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="/es/2020/04/cibernetica-en-el-breve-diccionario-filosofico-1954/">Post 1</a></td>
      <td>2.72 KB</td>
      <td>12.39 KB</td>
    </tr>
    <tr>
      <td><a href="/es/2020/05/cibernetica-al-servicio-del-comunismo/">Post 2</a></td>
      <td>87.16 KB</td>
      <td>141.89 KB</td>
    </tr>
    <tr>
      <td><a href="/es/2020/05/cuando-la-inteligencia-artificial-desplazo-la-cibernetica/">Post 3</a></td>
      <td>3.27 KB</td>
      <td>15.04 KB</td>
    </tr>
    <tr>
      <td>All three posts</td>
      <td>93.16 KB</td>
      <td>158.32 KB</td>
    </tr>
  </tbody>
</table>

<p>As it can be seen, the Lunr index grows linearly to the size of the text, but also it becomes larger than the text itself! At least for this small amount of content, it would be better to just download the text of the posts.</p>

<p>Maybe Lunr was too fancy for me, so I should implement my own search library.</p>

<h2 id="heading-putting-it-down-in-words" class="heading">
<a class="heading-link" href="#heading-putting-it-down-in-words">§</a>Putting it down in words</h2>

<p>The basic functionality of a search function is to map a query to posts that contain them. So a very initial implementation would be to collect all the words from all the posts and map each one to a list of posts. Then, when the user enters a query, the words of such query can be found in the search index.</p>

<p>As this site uses Jekyll, the static generation of the index would be in Ruby, while the search of the index would be in Javascript. Let’s focus on the former.</p>

<p>I’ll show some snippets of code, but they are greatly simplified and are not expected to actually run:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">site</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">docs</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
    <span class="n">rendered_content</span> <span class="o">=</span> <span class="n">site</span>
        <span class="p">.</span><span class="nf">liquid_renderer</span>
        <span class="p">.</span><span class="nf">file</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="nf">path</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="nf">content</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="n">site</span><span class="p">.</span><span class="nf">site_payload</span><span class="p">)</span>
    <span class="n">html_content</span> <span class="o">=</span> <span class="n">site</span>
        <span class="p">.</span><span class="nf">find_converter_instance</span><span class="p">(</span><span class="no">Jekyll</span><span class="o">::</span><span class="no">Converters</span><span class="o">::</span><span class="no">Markdown</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="n">rendered_content</span><span class="p">)</span>

    <span class="n">text_content</span> <span class="o">=</span> <span class="n">html_content</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/&lt;\/?[^&gt;]*&gt;/</span><span class="p">,</span> <span class="s1">' '</span><span class="p">)</span>
    <span class="o">...</span></code></pre></figure>

<p>In this iterator, the posts of the site are programmatically rendered using the Liquid parser and the Markdown converter to HTML. The result is the HTML as it would be displayed by the web browser. Then, the HTML tags are stripped, so what remains is the pure text content.</p>

<p>Let’s get the words:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="o">...</span>
    <span class="n">lang</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="s1">'lang'</span><span class="p">]</span>
    <span class="n">valid_chars</span> <span class="o">=</span> <span class="s1">'a-zA-Z0-9áéíóúàèìòùäëïöüâêîôûçñÁÉÍÓÚÀÈÌÒÙÄËÏÖÜÂÊÎÔÛÇÑ·'</span>

    <span class="n">text_content</span> <span class="o">=</span> <span class="n">text_content</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/[^</span><span class="si">#{</span><span class="n">valid_chars</span><span class="si">}</span><span class="sr">]/</span><span class="p">,</span> <span class="s1">' '</span><span class="p">)</span>

    <span class="n">words</span> <span class="o">=</span> <span class="n">text_content</span><span class="p">.</span><span class="nf">downcase</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/\s+/</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">filter</span> <span class="p">{</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span> <span class="n">word</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">filter</span> <span class="p">{</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span> <span class="o">!</span><span class="n">word</span><span class="p">.</span><span class="nf">match?</span><span class="p">(</span><span class="sr">/^\d+$/</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">filter</span> <span class="p">{</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span> <span class="o">!</span><span class="n">stopwords</span><span class="p">[</span><span class="n">lang</span><span class="p">].</span><span class="nf">include?</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">sort</span>
        <span class="p">.</span><span class="nf">uniq</span>
    <span class="o">...</span></code></pre></figure>

<p>Here the <code class="language-plaintext highlighter-rouge">text_content</code> string is filtered, excluding anything that is not a valid character in one of the languages of the blog. This means that punctuation marks or other symbols are removed.</p>

<p>Then, the resulting string is split by words, excluding short ones or numbers. A list of stopwords for the language of the post is used to remove common words, like “then” or “one”. There are projects that maintain lists of stopwords, like <a href="https://github.com/nltk/nltk_data/blob/gh-pages/packages/corpora/stopwords.zip" class="link-external">NLTK</a>.</p>

<p>Finally, the words are sorted and duplicates are removed. Great! This is the list of unique words from one post, after removing garbage like stopwords, short words or numbers. Let’s add them to the index:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="o">...</span>
    <span class="n">words</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">word</span><span class="p">,</span> <span class="n">count</span><span class="o">|</span>
        <span class="n">index</span><span class="p">[</span><span class="n">lang</span><span class="p">]</span> <span class="o">||=</span> <span class="p">{}</span>
        <span class="n">index</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="n">word</span><span class="p">]</span> <span class="o">||=</span> <span class="p">[]</span>
        <span class="n">index</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="n">word</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">post_index</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Note that per each word in a given language, it maps to a list of posts referenced by an “index”. This index is the position in the array of posts at the end of the index structure.</p>

<p>Let’s use an example. The following snippet is taken from the Markdown source of this <a href="/en/2024/07/cybernetics-in-a-Dictionary-of-philosophy-1967/">post</a>:</p>

<p><code class="language-plaintext highlighter-rouge">**Cybernetics**[^1], the science of the common features of processes and control systems in technological devices, living organisms and human organisations. The principles of C. were first set forth by Wiener (q.v.)</code></p>

<p>After rendering it:</p>

<p><code class="language-plaintext highlighter-rouge">&lt;p&gt;&lt;strong&gt;Cybernetics&lt;/strong&gt;&lt;sup id="fnref:1" role="doc-noteref"&gt;&lt;a href="#fn:1" class="footnote" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, the science of the common features of processes and control systems in technological devices, living organisms and human organisations. The principles of C. were first set forth by Wiener (q.v.).&lt;p&gt;</code></p>

<p>After removing the HTML tags:</p>

<p><code class="language-plaintext highlighter-rouge">Cybernetics 1, the science of the common features of processes and control systems in technological devices, living organisms and human organisations. The principles of C. were first set forth by Wiener (q.v.).</code></p>

<p>Removing the invalid characters:</p>

<p><code class="language-plaintext highlighter-rouge">Cybernetics 1 the science of the common features of processes and control systems in technological devices living organisms and human organisations The principles of C were first set forth by Wiener q v</code></p>

<p>And after filtering out short words, numbers and stopwords:</p>

<p><code class="language-plaintext highlighter-rouge">Cybernetics science common features processes control systems technological devices living organisms human organisations principles set forth Wiener</code></p>

<p>Last step, sorting and removing repeated words:</p>

<p><code class="language-plaintext highlighter-rouge">common control cybernetics devices features forth human living organisations organisms principles processes science set systems technological wiener</code></p>

<p>From this, the index would look as follows:</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"en"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"common"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"control"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"cybernetics"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"devices"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"features"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"forth"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"human"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"living"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"organisations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"organisms"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"principles"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"processes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"science"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"set"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"systems"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"technological"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
            </span><span class="nl">"wiener"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"posts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/en/2024/07/cybernetics-in-a-Dictionary-of-philosophy-1967/"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"“Cybernetics” (in A Dictionary of Philosophy, 1967)"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2024-07-27 19:00:00 +0200"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"lang"</span><span class="p">:</span><span class="w"> </span><span class="s2">"en"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>The current JSON search index in this format for the 7 posts in 3 languages of the site is 52 KB. Not bad compared to the 141 KB of Lunr for just 3 posts. All in all, 50 KB or 140 KB may be are not very important nowadays, as some images in this site are larger than that. But I’d like this blog to grow enough so the size of the index matters.</p>

<h2 id="heading-wait-doesnt-that-look-like-a-bloom-filter" class="heading">
<a class="heading-link" href="#heading-wait-doesnt-that-look-like-a-bloom-filter">§</a>Wait, doesn’t that look like a Bloom filter?</h2>

<p>Indeed, why not use a <a href="https://en.wikipedia.org/wiki/Bloom_filter" class="link-wikipedia">Bloom filter</a>, instead of a map of words? After all, a Bloom filter is super compact: 1 bit per word!</p>

<p>The issue is that a Bloom filter only tells you if a given entry is (probably) part of a set. In other words, it maps a given key to a <em>boolean value.</em> But in my case each key must map to a <em>list of values,</em> the posts that contain that word.</p>

<p>There are two alternatives. One is to implement a Bloom filter per post. But that would be prohibitive as the number of posts grows. The other is to implement a modified Bloom filter that can store <em>values.</em></p>

<p>Some kind of <em>Bloom map.</em></p>

<p>Each entry in the Bloom table would be a set, containing the values that were assigned by the hash functions. Then, the test operation would return the subset of values present in all the entries mapped by the key, if any.</p>

<p>As far as I know, no such hybrid between a Bloom filter and a hash table exists. Maybe for a reason? I am not 100% sure if this would really preserve the accuracy of a Bloom filter, but I made a quick implementation. The result is that even using very compact encodings of this Bloom map (I’m talking about base 36 indices for sparse tables) it still would be less efficient than the previous approach that just stores the list of words. In particular, the Bloom maps would need 82 KB, compared to the 52 KB of the word map.</p>

<p>I’ll leave that implementation in a branch. Maybe, in the long run, it outperforms the word map.</p>

<h2 id="heading-levenshtein-and-his-friends-burkhard-and-keller" class="heading">
<a class="heading-link" href="#heading-levenshtein-and-his-friends-burkhard-and-keller">§</a>Levenshtein and his friends Burkhard and Keller</h2>

<p>Now that the search index is generated, it’s time to do some searching in the web browser.</p>

<p>The search index contains (almost) all the words of the posts. A trivial approach would be to take the search query word by word and try to match it against the index. Every time there is a match, one point is given to the matched posts. If the query has 4 words, then the maximum score would be 4. The matching posts are displayed sorted by their score.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nf">search</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">word_map</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">query_words</span> <span class="o">=</span> <span class="p">[...</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">(</span>
    <span class="nf">to_ansi</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">)</span>
  <span class="p">)];</span>
  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">;</span>
  <span class="nx">index</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">lang</span><span class="p">,</span> <span class="nx">word_map</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">query_words</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">query_word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="nx">word_map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">query_word</span><span class="p">);</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">posts</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">post_index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">score</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">post_index</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
          <span class="nx">results</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">post_index</span><span class="p">,</span> <span class="nx">score</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>That will be the base search algorithm, but I would like it to be slightly smarter than that. After all, we are all used to fancy search engines that will find similar words, or match just prefixes. Instead of doing an exact match of the words in the index, the search could find <em>similar</em> words. An obvious optimization is to ignore accents. But how to match other similarities? For instance, “cybernetics” is very similar to “cibernètica” (Catalan).</p>

<p>Enter Levenshtein.</p>

<p>The <em>similarity</em> between two words could be defined as the <em>distance</em> between these words. This is what the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" class="link-wikipedia">Levenshtein distance</a> function does: it calculates how far away two words are. The distance is defined as how many letters need to be added, removed or substituted to go from one word to the other. In the case of “cybernetics”, it needs 2 substitutions to become “cibernètica”, if we ignore the accents.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nf">search</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">word_map</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">query_words</span> <span class="o">=</span> <span class="p">[...</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">(</span>
    <span class="nf">to_ansi</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">)</span>
  <span class="p">)];</span>
  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">;</span>
  <span class="nx">index</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">lang</span><span class="p">,</span> <span class="nx">word_map</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">query_words</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">query_word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">max_distance</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">query_word</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
      <span class="nx">word_map</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">posts</span><span class="p">,</span> <span class="nx">index_word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nf">levenshtein_distance</span><span class="p">(</span><span class="nx">query_word</span><span class="p">,</span> <span class="nx">index_word</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">distance</span> <span class="o">&lt;=</span> <span class="nx">max_distance</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">posts</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">post_index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
              <span class="kd">const</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">distance</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">query_word</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">index_word</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
              <span class="nx">results</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">post_index</span><span class="p">,</span> <span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">post_index</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">score</span><span class="p">);</span>
          <span class="p">});</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Good, we now have a precise definition of similarity. So the search algorithm can match not only exact words from the index, but also similar words whose Levenshtein distance is below a certain threshold (in particular, the maximum distance allowed is 1/3 of the length of the word, in other words, two words should share 2/3 of their letters to be considered similar).</p>

<p>Also, now the score is not 1 per each match, because matches may be similar but not exact. How exact? The normalized distance between the words, meaning a distance of 1 in a 5-letter word is an 80% similarity.</p>

<p>But there is another difference between this code and the previous one: before it was using a map to find exact matches, which is fast, while now it is comparing each word from the query to each word from the index. It has gone from O(1) to O(n<sup>2</sup>)!<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>Let’s bring some friends of Levenshtein to the party. In particular, Burkhard and Keller and their tree structure, the <a href="https://en.wikipedia.org/wiki/BK-tree" class="link-wikipedia">BK-Tree</a>. A BK-Tree is a data structure that can organize values based on their relative distance, and allows to quickly navigate it to find the values with a similarity below the given threshold.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nf">build_forest</span><span class="p">(</span><span class="nx">word_map</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">forest</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">;</span>
  <span class="nx">index</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">lang</span><span class="p">,</span> <span class="nx">word_map</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BKTree</span><span class="p">(</span><span class="nx">levenshtein_distance</span><span class="p">);</span>
    <span class="nx">word_map</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">posts</span><span class="p">,</span> <span class="nx">index_word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">tree</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">index_word</span><span class="p">,</span> <span class="nx">posts</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">forest</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">lang</span><span class="p">,</span> <span class="nx">tree</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">forest</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">search</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">word_map</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">query_words</span> <span class="o">=</span> <span class="p">[...</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">(</span>
    <span class="nf">to_ansi</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">)</span>
  <span class="p">)];</span>

  <span class="kd">let</span> <span class="nx">forest</span> <span class="o">=</span> <span class="nf">build_forest</span><span class="p">(</span><span class="nx">word_map</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">;</span>

  <span class="nx">forest</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">tree</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">query_words</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">query_word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">max_distance</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">query_word</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
      <span class="nx">tree</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">query_word</span><span class="p">,</span> <span class="nx">max_distance</span><span class="p">).</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">search_result</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">search_result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">post_index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="kd">const</span> <span class="nx">score</span> <span class="o">=</span> <span class="nx">search_result</span><span class="p">.</span><span class="nx">score</span><span class="p">;</span>
          <span class="nx">results</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">post_index</span><span class="p">,</span> <span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">post_index</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">score</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In this new code, a BK-Tree is constructed for each word index, and now these trees can be used to search for similar words below a certain threshold with a time complexity of O(log n). That’s more like it.</p>

<h2 id="heading-looking-for-the-headline" class="heading">
<a class="heading-link" href="#heading-looking-for-the-headline">§</a>Looking for the headline</h2>

<p>The fuzzy search function that was implemented above will match similar words. But surely the user, after typing “cyber”, will expect <a href="/en/2024/07/cybernetics-in-a-Dictionary-of-philosophy-1967/">“Cybernetics” (in A Dictionary of Philosophy, 1967)</a> to appear in the results.</p>

<p>Implementing a prefix match for all the words is possible, for instance with a <a href="https://en.wikipedia.org/wiki/Radix_tree" class="link-wikipedia">radix tree</a> structure. But that would probably generate too many results, many of them unuseful. If the user types “app”, do they want results about applications but also about apples?</p>

<p>Still, what is overkill for the content can be adequate if limited to the title. In addition to the score provided by the fuzzy search with the word map, I also added a substring search:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nf">search_titles</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">post_list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">query_words</span> <span class="o">=</span> <span class="p">[...</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">(</span>
    <span class="nf">to_ansi</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span>
    <span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">)</span>
  <span class="p">)];</span>

  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">;</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">post_list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">post_list</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">title</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">query_words</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">query_word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">title</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">word</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">score</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">});</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">results</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">score</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The previous code takes the words of the search query and checks if they are a substring of a post title. For each word that is a substring of a title, that post gets 1 point. The score of the title search is added to the score of the fuzzy search, and that is how posts are displayed in the search box and how they are sorted.</p>

<h2 id="heading-conclusion" class="heading">
<a class="heading-link" href="#heading-conclusion">§</a>Conclusion</h2>

<p>I am quite satisfied with the static search function I implemented for this website. It is quite lightweight: 52 KB, compared to the 141 KB of Lunr or the 82 KB of a <em>Bloom map.</em> Still, the search experience feels similar to what can be expected from a full text search. Go ahead and test it yourself.</p>

<p>Obviously, searching web pages is complicated, after all Google was built around this. If I type for “levens” I want the search function to return me results for Levenshtein, but that will not happen as it is too dissimilar (45% similarity). And yet, it will match “leaves” and “even” (66% similarity).</p>

<p>As the blog grows, maybe I will have to revisit the implementation in case the index becomes too heavy, or it is not very accurate, but for now does the job.</p>

<h2 id="heading-notes" class="heading">
<a class="heading-link" href="#heading-notes">§</a>Notes</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>The count of visible characters of the post’s text, as seen in the web browser, excluding white spaces. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>See <a href="https://en.wikipedia.org/wiki/Big_O_notation" class="link-wikipedia">Big O Notation</a>. Also, technically, it has gone from O(1) to O(n m). <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>



        </div>
        <div class="clear"></div>

    </article>
    <!-- <div class="brutalist_themes__related_posts">

        <h4 class="widget-title">You might also like</h4>

        <ul>
            <li itemscope="" itemtype="http://schema.org/blogPost">
                <a class="title" href="https://lamaquinadeturing.su/2020/05/01/cibernetica-al-servicio-del-comunismo/"
                    title="Cibernética – al servicio del comunismo">
                    <img src="index_fitxers/cybernetics-150x150.png"
                        class="attachment-thumbnail size-thumbnail wp-post-image"
                        alt="Cibernética – al servicio del comunismo" itemprop="image"
                        itemtype="http://schema.org/thumbnailUrl" width="150" height="150">
                    <h5 itemscope="" itemtype="http://schema.org/headline">Cibernética – al servicio del
                        comunismo</h5>
                </a>
            </li>
            <li itemscope="" itemtype="http://schema.org/blogPost">
                <a class="title"
                    href="https://lamaquinadeturing.su/2020/05/01/cuando-la-inteligencia-artificial-desplazo-la-cibernetica/"
                    title="Cuando la inteligencia artificial desplazó la cibernética">
                    <img src="index_fitxers/darthsmouth-1-150x150.jpg"
                        class="attachment-thumbnail size-thumbnail wp-post-image"
                        alt="Cuando la inteligencia artificial desplazó la cibernética" itemprop="image"
                        itemtype="http://schema.org/thumbnailUrl" width="150" height="150">
                    <h5 itemscope="" itemtype="http://schema.org/headline">Cuando la inteligencia artificial
                        desplazó la cibernética</h5>
                </a>
            </li>
        </ul>
        <div class="clear"></div>
    </div> -->
</div>

<div class="grid__item">

    <aside class="widget-area" itemscope="" itemtype="http://schema.org/WPSideBar">
    
    <div class="widget element__frame widget_toc">
        <h3 class="widget-title">Contents</h3>
        <p class="toc toc-h2"><a href="#heading-the-poor-mans-search-function">The poor man’s search function</a></p><p class="toc toc-h2"><a href="#heading-is-static-search-even-possible">Is static search even possible?</a></p><p class="toc toc-h2"><a href="#heading-putting-it-down-in-words">Putting it down in words</a></p><p class="toc toc-h2"><a href="#heading-wait-doesnt-that-look-like-a-bloom-filter">Wait, doesn’t that look like a Bloom filter?</a></p><p class="toc toc-h2"><a href="#heading-levenshtein-and-his-friends-burkhard-and-keller">Levenshtein and his friends Burkhard and Keller</a></p><p class="toc toc-h2"><a href="#heading-looking-for-the-headline">Looking for the headline</a></p><p class="toc toc-h2"><a href="#heading-conclusion">Conclusion</a></p><p class="toc toc-h2"><a href="#heading-notes">Notes</a></p>
    </div>
    
    <div class="widget element__frame widget_recent_entries">
        <h3 class="widget-title">Recent Posts</h3>
        <ul>
            
                
            <li>
                <a href="/en/2024/10/git-rebase-onto/">Git rebase doesn't do what you think</a>
                
            </li>
            
                
            <li>
                <a href="/en/2024/09/simple-sabotage-field-manual/">Simple Sabotage Field Manual</a>
                
            </li>
            
                
            <li>
                <a href="/en/2024/08/the-case-for-a-better-web/">The case for a better web</a>
                
            </li>
            
                
            <li>
                <a href="/en/2024/08/this-website-does-not-use-cookies/">This website does not use cookies</a>
                
            </li>
            
                
            <li>
                <a href="/en/2024/08/implementing-search-function-in-static-web-site/">Implementing the search function in a static web site</a>
                
            </li>
            
        </ul>
    </div>
    <!-- <div id="archives-2" class="widget element__frame widget_archive">
        <h3 class="widget-title">Archives</h3>
        <ul>
            <li><a href="https://lamaquinadeturing.su/2021/08/">August 2021</a></li>
            <li><a href="https://lamaquinadeturing.su/2020/05/">May 2020</a></li>
            <li><a href="https://lamaquinadeturing.su/2020/04/">April 2020</a></li>
        </ul>
    </div> -->
    <div class="widget element__frame widget_categories">
        <h3 class="widget-title">Categories</h3>
        <ul>
            
            
            
            
            
            
            <li class="cat-item cat-item-2"><a href="/en/cybernetics/">Cybernetics</a></li>
            
            <li class="cat-item cat-item-2"><a href="/en/lzhenauka/">Lzhenauka</a></li>
            
            <li class="cat-item cat-item-2"><a href="/en/web/">Web</a></li>
            
            
            
            
            
        </ul>
    </div>
    <div class="clear"></div>
</aside>

</div>

        </section>
        

        <footer id="site-footer" itemscope="" itemtype="http://schema.org/WPFooter">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.ca">CC BY-SA</a> · La màquina de Turing ·
    <a href="/en/2024/08/this-website-does-not-use-cookies/">This website does not use cookies</a>
</footer>
    </div>

    <a class="element__frame scroll-top" href="#scroll-top" title="scroll top" style="display: none;">
        <p class="bar__title">Top</p>
    </a>
</body>
</html>